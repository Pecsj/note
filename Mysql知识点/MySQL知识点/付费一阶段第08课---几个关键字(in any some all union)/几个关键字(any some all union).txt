
	知识回顾
	1.去重复   distinct-----(可以理解为分组)
		distinct 列 , 列	如果是两个列  两个列的组合当做整体
		列，distinct 列	可能会产生第二个列去重复后个数减少
	2.分组之后想要再深入进行分析
		分组条件+分组函数
		1.group by 列
		2.一旦搭配了分组条件来进行分析
		   想要显示的最终结果只能是两种情况    分组条件   分组函数
		3.分组时候可能会产生与条件筛选相关的操作
		       如果先进行条件筛选  后分组     where     group-by
		       如果先进行分组  后进行筛选     group-by    having
		       如果分析之后还需要进行排序   order-by  最后处理
	3.嵌套
		将一条完整的SQL嵌套在另一条完整的SQL内部
		*1.可以将查询的结果当做条件    再次查询
			select * from student where chinese = (select max(chinese) from student);
			在这种情况下有可能 嵌套的子SQL查询的表格与当前的SQL不一致
		2.可以将查询的结果当做一张新的表格   表格基础上再次查询
			select * from (select sid,sname,ssex,sage from student) xxx;
			需要注意from后面的表格需要有名字  给表格起别名 

	==========================================================

	几个关键字使用
	in	满足查询子集中的某一个即可	默认=比较
		in后面的自己内   可以是常量固定值
		也可以是通过另一条sql语句查询出来的结果 
		in()    not in ();

	如下的三个使用起来与in类似    查询是否满足后面的子集中的条件
	关键字的后面不允许写固定值    只允许写sql语句(只能通过嵌套来获取子集)
	any	满足查询子集中的某一个即可	>any   <any    =any(结果与in)   !=any
	some	与any完全一致
	all	满足查询子集中的全部才可以	>all     <all      =all     !=all(结果与not in)

	----------------------------------------------------------------
	集合操作    并集   (oracle数据库有-->交集intersect   差集minus)
	union(结合 合并的意思  并集)
	
	有两张表格    学生信息    老师信息
	我们的学校想要召开运动会
	学校想要给所有的老师和同学都准备统一的服装
	这时候就需要统计全学校所有的人的信息
	
	select tid,tname,tsex from teacher union select sid,sname,ssex from student;

	1.要求前后两个查询子集的列数是一致
	2.类型没有要求
	3.拼接后显示的列名是前一个子集默认的列名
	*4.注意  union和union all的区别
		union合并后做去重复的处理	性能比较慢
		          如果产生重复元素   记录的是第一次出现的那一行
		union all 将两个查询的字节直接做合并
		          不做任何处理   性能比较快
		          建议以后尽量使用union all来进行合并处理
	
	=================================================

	小任务：
	员工编号    姓名    部门      生日              工资      职务        信息更新时间
	     1        赵一一     C     '1980-10-11' 10000  程序员      系统当前时间  now()
	     2        钱二二     C      1981-10-12  20000  程序员      系统当前时间
	     3        孙三三     C      1982-9-1      30000  项目经理   系统当前时间 
	     4        李四四  JAVA  1983-9-2      40000  程序员       系统当前时间
	     5        周五五  JAVA  1984-11-1    50000  程序员       系统当前时间
	     6        吴六六  JAVA  1985-1-1      50000  程序员       系统当前时间
	     7        郑七七  JAVA  1986-11-2    70000  项目经理   系统当前时间
	-----------------------------------------------------------------------------
	1.请建立Users表保存员工的相关信息，生日，信息更新时间用date类型 
	2.查询每个部门最高工资,最低工资,平均工资
	3.给所有项目经理工资涨10000
	4.给工资低于30000的员工工资涨到30000
	5.查询各部门的工资总额，平均工资，最高工资，最低工资
	6.C部门的项目经理离职，删除其信息
	7.C部门的程序员全部转入JAVA部门，更改信息
	8.查询11月份过生日的员工
	9.查询本月过生日的员工。设计一个通用的语句，不要用11月判断 
	10.查询整合部门后表中记录的所有记录 按照薪资从高到低排布

	==========================================

	EMP员工表
	empno  ename   job      mgr      hiredate    sal    comm  deptno
	  编号     姓名        职务     上级       入职日期    月薪  佣金  部门
	(7369,'SMITH','CLERK',7902,'1980-12-17',800,NULL,20),
	(7499,'ALLEN','SALESMAN',7698,'1981-2-20',1600,300,30),
	(7521,'WARD','SALESMAN',7698,'1981-2-22',1250,500,30),
	(7566,'JONES','MANAGER',7839,'1981-4-2',2975,NULL,20),
	(7654,'MARTIN','SALESMAN',7698,'1981-9-28',1250,1400,30),
	(7698,'BLAKE','MANAGER',7839,'1981-5-1',2850,NULL,30),
	(7782,'CLARK','MANAGER',7839,'1981-6-9',2450,NULL,10),
	(7788,'SCOTT','ANALYST',7566,'1987-4-19',3000,NULL,20),
	(7839,'KING','PRESIDENT',NULL,'1981-11-17',5000,NULL,10),
	(7844,'TURNER','SALESMAN',7698,'1981-9-8',1500,0,30),
	(7876,'ADAMS','CLERK',7788,'1987-5-23',1100,NULL,20),
	(7900,'JAMES','CLERK',7698,'1981-12-3',950,NULL,30),
	(7902,'FORD','ANALYST',7566,'1981-12-3',3000,NULL,20),
	(7934,'MILLER','CLERK',7782,'1982-1-23',1300,NULL,10)
	-------------------------------------------------------
	DEPT部门表
	部门编号    部门名称     坐落城市
	deptno      dname       loc
	(10,'ACCOUNTING','NEW YORK'),
	(20,'RESEARCH','DALLAS'),
	(30,'SALES','CHICAGO'),
	(40,'OPERATIONS','BOSTON')
	-------------------------------------------------------
	--条件筛选练习(EMP表)
	1.查询部门30中的雇员
	2.查询所有办事员(CLERK)的姓名、编号和部门
	3.查询佣金(comm)高于薪金(sal)的雇员
	4.查询哪些人没有佣金(comm)
	5.查询佣金(comm)高于薪金(sal)60%的雇员
	7.显示所有人的姓名,月薪,年薪(起别名)
	8.找出部门10中所有经理和部门20中的所有办事员的详细资料
	9.找出部门10中所有经理、部门20中所有办事员，
	   既不是经理又不是办事员，但其薪金>=2000的所有雇员的资料
	10.找出不收取佣金或收取的佣金低于500的雇员

	--排序练习(EMP表)
	11.查询所有人员信息,按照工资升序排列
	12.查询所有人员姓名,工资,佣金,按照工资降序排列,若工资相同则按照佣金升序排列
	13.查询工资大于两千的所有员工,按照工资降序排列
	14.查询所有人的信息,按照姓名排序
	15.查询工资在2000-3000之间的员工信息，按照雇佣日期升序排列

	--函数练习(EMP表)
	16.显示正好为6个字符的雇员姓名
	17.显示所有雇员的姓名的前三个字符
	18.显示所有雇员的姓名，用a替换所有'A'
	19.显示不带有'R'的雇员姓名
	20.显示只有首字母大写的所有雇员的姓名(MySQL不区分)
	21.找出早于35年之前受雇的雇员
	22.显示所有雇员的姓名以及满10年服务年限的日期

	--分组函数练习(EMP表)
	23.显示每种工作的人数
	24.显示工作人数大于3的工作的平均工资
	25.显示出经理有几种不同的工资
	26.显示出30号部门有几种不同的工作
	27.显示出emp表数据中不同月份雇佣的人数
	28.显示出每个管理者手下带了多少个员工
	29.显示收取佣金的雇员的不同工作

	--嵌套查询练习(EMP表)
	30.查询平均工资大于2900的部门中的所有员工
	31.查询工资比ALLEN多的所有员工
	32.查询薪金高于公司平均薪金的所有员工姓名,部门编号,具体薪资
	33.列出与scott从事相同工作的所有员工信息
	34.查询薪金大于部门30中的员工最高薪金的所有员工的姓名、薪金和部门编号
	35.查询在部门sales工作的员工的姓名
