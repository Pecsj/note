知识回顾
	修饰符
	权限
	public  protected   默认不写   private
	public  公有的   当前工程的任意位置访问
	protected  保护的   本类  同包  子类
	默认不写     默认的   本类  同包
	private      私有的    本类
	封装思想---->类   方法    保护属性   私有属性+共有get/set
	特征
	final   static   abstract   native   (transient   synchronized   volatile)
	final
		修饰变量	只有一次赋值的机会  不能再发生改变
		修饰属性	要求必须赋初始值  不能再次发生改变
		修饰方法	该方法不能被子类重写(覆盖)
		修饰类	该类不能被其他的子类继承
	static
		修饰属性   修饰方法   修饰块   修饰内部类
		1.静态元素在类加载时即被初始化，创建的很早，创建时只有类，还没有对象
		2.静态元素存储在静态元素区中，每一个类有一个单独的自己的区域，与别的类不冲突
		3.静态元素区不能被GC管理，可以简单粗暴的认为静态元素常驻内存
		4.静态元素只加载一次(只存在一份儿)，全部类对象及类本身共享
		5.可以理解为静态元素与对象没有关系，属于类的
		6.由于静态元素在加载的时候有可能没有创建对象，我们可以通过类名字直接访问
		7.静态元素可以直接访问静态元素(都存在静态元素区中)
		8.非静态元素可以直接访问静态元素(非静态-->堆内存对象空间里 静态元素--->静态区)
		9.静态元素不可以访问非静态元素(静态元素是单独存在--->找寻非静态元素 有一堆一样的 说不清)
		10.静态元素中不可以使用this或super关键字(静态元素可以理解为属于类 this/super代替对象)

	静态常量的应用场景
	增强程序的可读性   static final 属性=0
==========================================================================
	设计模式  23种  (内功心法)
	1.设计模式不是知识点
	2.设计模式是一种设计经验的总结
	3.设计模式用来解决某些场景下的某一类问题的---->通用的解决方案
	4.有了设计模式之后  可以让代码更容易被理解  确保了复用性  可靠性  可扩展性

	设计模式分为三类
	1.创建型模式(5种)----->用于解决对象创建的过程
		单例模式  工厂方法模式   抽象工厂模式   建造者模式   原型模式
	2.结构型模式(7种)----->把类或对象通过某种形式结合在一起  构成某种复杂或合理的结构	
		适配器模式  装饰者模式   代理模式  外观模式   桥接模式   组合模式   享元模式
	3.行为型模式(11种)---->用来解决类或对象之间的交互  更合理的优化类或对象之间的关系
		观察者模式  策略模式  模板模式  责任链模式  解析器模式  迭代子模式 
		命令模式  状态模式  备忘录模式  访问者模式  中介者模式

====================================================================
	单例模式(Singleton)
		设计-->一个类只能创建一个对象  有效减少内存占用空间
		设计一个系统--->百度   搜索引擎
			public class Baidu{
				public void 搜索(String keyword){
				}
			}
		创建一个Baidu对象  new
		调用搜索的方法  做事情  方法执行一遍
		同一时间有很多很多很多很多人在使用这个系统
		对象--->只创建一个  堆内存中就只开辟一个空间
		调用一次方法--->临时执行一次   方法执行空间就回收啦

		单例模式的实现
		1.私有的构造方法
		2.私有的静态的当前类对象作为属性
		3.公有的静态的方法返回当前类对象

		指的是对象的加载
		饿汉式(立即加载)   对象启动时就加载啦
			不会产生对象没有就拿来使用的问题  空指针异常
			启动项目加载的对象过多  有些还没有使用  产生服务器承载压力的问题
		懒汉式(延迟加载)   对象什么时候用到了 才会加载
			可能会由于没有操作好  导致异常(很严谨)
			启动项目时候只有需要的加载  不需要的还没有创建  不会浪费空间
		*生命周期托管(单例对象别人帮我们处理)   对象加载过程交给别人






		